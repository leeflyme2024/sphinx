# 源代码
```c
// src\zy\ti-processor-sdk-linux-rt-am62xx-evm-08.06.00.42\board-support\u-boot-2021.01+gitAUTOINC+2ee8efd654-g2ee8efd654\drivers\zy\net\phy\cfg\emmc_boot.c
#include <common.h>
#include <env.h>
#include <dm.h>
#include <init.h>
#include <asm/arch/sys_proto.h>
#include <asm/arch/hardware.h>
#include <asm/gpio.h>
#include <asm/io.h>
#include <asm/omap_common.h>
#include <soc.h>
#include <asm/arch/sys_proto.h>
#include <command.h>
#include <errno.h>
#include <fdtdec.h>
#include <malloc.h>
#include <watchdog.h>
#include <dt-bindings/pinctrl/k3.h>
#include <generated/version_autogenerated.h>
#include <blk.h>
#include <console.h>
#include <memalign.h>
#include <mmc.h>
#include <part.h>
#include <sparse_format.h>
#include <image-sparse.h>
#include <malloc.h>
#include <exports.h>
#include <string.h>

DECLARE_GLOBAL_DATA_PTR;

#ifdef CONFIG_DATA_USE_HUFFMAN
#include "huffman.h"
#endif

#include "md5.h"
#include "cJSON.h"
#include "emmc_boot.h"

#define MD5_DIGEST_LENGTH 16
#define DEBUG() printf("-------%s--%d-------\n", __func__, __LINE__)

static int cfg_mmc_init(char *original_part, int bus)
{
    int err;
    struct mmc *mmc;
    bool force_init = false;

    err = mmc_init_device(bus);
    if (err) {
        printf("could not initialize mmc. error: %d\n", err);
        return err;
    }

    mmc = find_mmc_device(bus);
    if (!mmc) {
        printf("could not find mmc device %d\n", bus);
        return -ENODEV;
    }

    if (!mmc_getcd(mmc))
        force_init = true;

    if (force_init)
        mmc->has_init = 0;

    if (IS_ENABLED(CONFIG_MMC_SPEED_MODE_SET))
        mmc->user_speed_mode = MMC_MODES_END;

    if (mmc_init(mmc)) {
        printf("MMC initialization failed\n");
        return -EINVAL;
    }

#ifdef CONFIG_BLOCK_CACHE
    struct blk_desc *bd = mmc_get_blk_desc(mmc);
    blkcache_invalidate(bd->if_type, bd->devnum);
#endif

    if (!(mmc->version & MMC_VERSION_MMC)) {
        printf("Device is not an eMMC\n");
        return -EINVAL;
    }

#ifndef CONFIG_BLK
    *original_part = mmc->block_dev.hwpart;
#else
    *original_part = mmc_get_blk_desc(mmc)->hwpart;
#endif

    // 切换至 eMMC Boot0 分区
    if (blk_select_hwpart_devnum(IF_TYPE_MMC, bus, MMC_BOOT0_PARTITION) != 0) {
        printf("Failed to switch to boot0 partition\n");
        return -EINVAL;
    }

    return 0;
}

static int mmc_boot0_enable_write(struct mmc *mmc)
{
    int ret;

    // 设置分区访问为 eMMC Boot0
    ret = mmc_set_part_conf(mmc, 1, 1, 1);
    if (ret) {
        printf("Failed to set partition access to boot0: %d\n", ret);
        return ret;
    }

    return 0;
}

static int mmc_boot0_disable_write(struct mmc *mmc)
{
    int ret;

    // 设置分区访问为用户分区
    ret = mmc_set_part_conf(mmc, 0, 0, 0);
    if (ret) {
        printf("Failed to set partition access to user partition: %d\n", ret);
        return ret;
    }

    return 0;
}

static int prepare_data_for_write(const char *data, int len, char **content, int *blk_cnt)
{
    int size = 0;
    int d_size = len;
    char *str = NULL;
    char md5_str[32];
    unsigned char md5[MD5_DIGEST_LENGTH];
    unsigned char *value = (unsigned char *)data;

    // 哈夫曼编码
#ifdef CONFIG_DATA_USE_HUFFMAN
    huffman_encode((unsigned char *)data, len, &value, &d_size);
#endif

    // 计算数据大小及占用的块数量
    snprintf(md5_str, sizeof(md5_str), "<<%d>>", d_size);
    size = d_size + strlen(md5_str) + MD5_DIGEST_LENGTH;
    *blk_cnt = size / MMC_BLOCK_SIZE;
    if(size % MMC_BLOCK_SIZE) {
        (*blk_cnt) ++;
    }

    // 分配堆
    *content = malloc((*blk_cnt) * MMC_BLOCK_SIZE);
    if (!*content) {
        printf("Failed to allocate memory\n");
        return -ENOMEM;
    }

    // 清空堆
    memset(*content, 0, (*blk_cnt) * MMC_BLOCK_SIZE);

    // 处理数据
    str = *content + MD5_DIGEST_LENGTH;
    sprintf(str, "<<%d>>", d_size);
    str = strstr(str, ">>") + 2;
    memcpy(str, value, d_size);

    // 处理 MD5
    MD5((unsigned char *)(*content + MD5_DIGEST_LENGTH), size - MD5_DIGEST_LENGTH, md5);
    memcpy(*content, md5, MD5_DIGEST_LENGTH);

#ifdef CONFIG_DATA_USE_HUFFMAN
    if (value != (unsigned char *)data)
        free(value);
#endif

    return 0;
}

int mmc_boot_data_save(char *data, int len, int offset)
{

    int ret = 0;
    int blk_cnt = 0;
    struct mmc *mmc;
    unsigned long blk_start = 0;
    char *content = NULL, original_part;

    // 初始化 eMMC
    if(cfg_mmc_init(&original_part, CONFIG_CFG_EMMC_BUS)){
        printf("MMC initialization error\n");
        ret = -EINVAL;
        goto out;
    }

    // 查找 eMMC
    mmc = find_mmc_device(CONFIG_CFG_EMMC_BUS);
    if (!mmc) {
        printf("could not find mmc device %d\n", CONFIG_CFG_EMMC_BUS);
        ret = -ENODEV;
        goto out;
    }

    // 准备数据
    ret = prepare_data_for_write(data, len, &content, &blk_cnt);
    if (ret)
        goto out;

    // 计算起始块
    blk_start = offset / MMC_BLOCK_SIZE;

    // eMMC Boot0 分区写使能
    ret = mmc_boot0_enable_write(mmc);
    if (ret)
        goto free_content;

    // 写数据
    if (blk_dwrite(mmc_get_blk_desc(mmc), blk_start, blk_cnt, content) != blk_cnt) {
        printf("Failed to write data to MMC\n");
        ret = -EIO;
    }

    // 禁止写入 eMMC Boot0 分区
    mmc_boot0_disable_write(mmc);

free_content:
    // 释放堆空间
    free(content);

out:
    // 切换回用户分区
    if (blk_select_hwpart_devnum(IF_TYPE_MMC, CONFIG_CFG_EMMC_BUS, original_part) != 0) {
        printf("Failed to switch to user partition\n");
        ret = -EINVAL;
    }

    return ret;
}

int mmc_boot_data_get(char **data, int *len, int offset)
{
    struct mmc *mmc;
    unsigned long blk_start;
    char size_str[10] = {0,};
    int ret = 0, size, blk_cnt, i, d_size;
    char *content = NULL, *str, original_part;
    char md5[MD5_DIGEST_LENGTH], _md5[MD5_DIGEST_LENGTH];

    if(cfg_mmc_init(&original_part, CONFIG_CFG_EMMC_BUS)){
        printf("MMC init error\n");
        ret = -EINVAL;
        goto out;
    }

    mmc = find_mmc_device(CONFIG_CFG_EMMC_BUS);
    if (!mmc) {
        printf("could not find mmc device %d\n", CONFIG_CFG_EMMC_BUS);
        ret = -ENODEV;
        goto out;
    }

    blk_start = offset / MMC_BLOCK_SIZE;

    content = malloc(MMC_BLOCK_SIZE);
    if (!content) {
        ret = -ENOMEM;
        goto out;
    }

    if (blk_dread(mmc_get_blk_desc(mmc), blk_start, 1, content) != 1) {
        printf("Error: expected %d blocks read\n", 1);
        ret = -EIO;
        goto free_content;
    }
    free(content);

    content = malloc(MMC_BLOCK_SIZE);
    if (!content) {
        ret = -ENOMEM;
        goto out;
    }

    if (blk_dread(mmc_get_blk_desc(mmc), blk_start, 1, content) != 1) {
        printf("Error: expected %d blocks read\n", 1);
        ret = -EIO;
        goto free_content;
    }

    // 获取MD5数据
    memcpy(md5, content, sizeof(md5));

    // 获取json数据
    str = content + MD5_DIGEST_LENGTH;
    d_size = simple_strtoul(str + 2, NULL, 10);

    sprintf(_md5, "<<%d>>", d_size);
    size = d_size + strlen(_md5) + MD5_DIGEST_LENGTH;

    blk_cnt = size / MMC_BLOCK_SIZE;
    if(size % MMC_BLOCK_SIZE) {
        blk_cnt ++;
    }
    free(content);

    content = malloc(blk_cnt * MMC_BLOCK_SIZE);
    if (!content) {
        ret = -ENOMEM;
        goto out;
    }

    if (blk_dread(mmc_get_blk_desc(mmc), blk_start, blk_cnt, content) != blk_cnt) {
        printf("Error: expected %d blocks read\n", blk_cnt);
        ret = -EIO;
        goto free_content;
    }

    // MD5 校验
    str = content + MD5_DIGEST_LENGTH;
    MD5((unsigned char*)str, size - MD5_DIGEST_LENGTH, (unsigned char *)_md5);
    for (i = 0; i < MD5_DIGEST_LENGTH; i++) {
        if (md5[i] != _md5[i]) {
            printf("Data checksum error\n");
            ret = -EINVAL;
            goto free_content;
        }
    }

    // 提取数据
    sprintf(size_str, "<<%d>>", d_size);
    str = content + MD5_DIGEST_LENGTH + strlen(size_str);

    *data = malloc(d_size + 1);
    if (!*data) {
        ret = -ENOMEM;
        goto free_content;
    }
    memcpy(*data, str, d_size);
    (*data)[d_size] = '\0';
    *len = d_size;

free_content:
    free(content);

out:
    // 切换回用户分区
    if (blk_select_hwpart_devnum(IF_TYPE_MMC, CONFIG_CFG_EMMC_BUS, original_part) != 0) {
        printf("Failed to switch to user partition\n");
        ret = -EINVAL;
    }

    return ret;
}

#if defined(CONFIG_TARGET_AM625_R5_EVM) && defined(CONFIG_ZY_FASTBOOT)
// char *get_value_by_key(const char *json_data, const char *key)
// {
//     int result_len;
//     char *start, *end, *result, *data;

//     data = strdup(json_data);
//     if (data == NULL) {
//         printf("Memory allocation failed\n");
//         return NULL;
//     }

//     // 查找键
//     start = strstr(data, key);
//     if (start == NULL) {
//         printf("Key not found\n");
//         free(data);
//         return NULL;
//     }

//     // 查找键值的开始和结束位置
//     start = strchr(start, ':');
//     if (start == NULL) {
//         printf("Invalid JSON format\n");
//         free(data);
//         return NULL;
//     }
//     start++;

//     if (*start == '\"') {
//         start++;
//         end = strchr(start, '\"');
//     } else {
//         if ((end = strchr(start, ',')) == NULL) {
//             end = strchr(start, '}');
//         }
//     }

//     if (end == NULL) {
//         printf("Invalid JSON format\n");
//         free(data);
//         return NULL;
//     }

//     // 根据键值的位置创建结果字符串
//     result_len = end - start;
//     result = (char *)malloc(result_len + 1);
//     if (result == NULL) {
//         printf("Memory allocation failed\n");
//         free(data);
//         return NULL;
//     }

//     strncpy(result, start, result_len);
//     result[result_len] = '\0';

//     free(data);

//     return result;
// }

// char *replace_json_value(const char *json_data, const char *key, const char *new_val)
// {
//     char *new_json_data;
//     const char *key_start, *val_start, *val_end;
//     int len_before, len_after, new_val_len, len_total;

//     key_start = strstr(json_data, key);
//     if (!key_start) {
//         printf("Key not found\n");
//         return NULL;
//     }
//     key_start += strlen(key);
//     val_start = strchr(key_start, ':');
//     if (!val_start) {
//         printf("Invalid JSON format\n");
//         return NULL;
//     }
//     val_start++;
//     if (*val_start == '\"') {
//         val_start++;
//         val_end = strchr(val_start, '\"');
//     } else {
//         val_end = strpbrk(val_start, ",}");
//     }
//     if (!val_end) {
//         printf("Invalid JSON format\n");
//         return NULL;
//     }

//     new_val_len = strlen(new_val);
//     len_before = val_start - json_data;
//     len_after = strlen(val_end);
//     len_total = len_before + new_val_len + len_after;
//     new_json_data = malloc(len_total + 1);
//     if (!new_json_data) {
//         printf("Memory allocation failed\n");
//         return NULL;
//     }

//     strncpy(new_json_data, json_data, len_before);
//     strcpy(new_json_data + len_before, new_val);
//     strcpy(new_json_data + len_before + new_val_len, val_end);

//     return new_json_data;
// }

// char *get_mmc_data(const char *key)
// {
//     int ret, len;
//     int offset = CONFIG_CFG_MMC_BOOT0_OFFSET;
//     char *data = NULL, *value_out = NULL;

//     ret = mmc_boot_data_get(&data, &len, offset);
//     if (ret) {
//         printf("Failed to get MMC data: %d\n", ret);
//         free(data);
//         return NULL;
//     }

//     value_out = get_value_by_key(data, key);
//     if (value_out == NULL) {
//         printf("Failed to get value for key: %s\n", key);
//     }

//     free(data);
//     return value_out;
// }

// int set_mmc_data(const char *key, const char *new_val)
// {
//     int ret, len;
//     char *new_data = NULL, *data = NULL;
//     int offset = CONFIG_CFG_MMC_BOOT0_OFFSET;

//     ret = mmc_boot_data_get(&data, &len, offset);
//     if (ret) {
//         printf("Failed to get MMC data: %d\n", ret);
//         free(data);
//         return ret;
//     }

//     new_data = replace_json_value(data, key, new_val);
//     free(data);
//     if (!new_data) {
//         printf("Failed to replace JSON value\n");
//         return -1;
//     }

//     ret = mmc_boot_data_save(new_data, strlen(new_data), offset);
//     if (ret) {
//         printf("Failed to save new MMC data\n");
//     }
//     free(new_data);

//     return ret;
// }

// char *get_value_by_key(const char *json_data, const char *key)
// {
//     int result_len;
//     char *start, *end, *result, *data;
//     char *current_pos;
    
//     data = strdup(json_data);
//     if (data == NULL) {
//         printf("Memory allocation failed\n");
//         return NULL;
//     }

//     // 首先查找 "boot" 对象的开始
//     current_pos = strstr(data, "\"boot\"");
//     if (current_pos == NULL) {
//         printf("Boot object not found\n");
//         free(data);
//         return NULL;
//     }

//     // 确保找到的是 "boot" 对象
//     current_pos = strchr(current_pos, '{');
//     if (current_pos == NULL) {
//         printf("Invalid JSON format: no opening brace for boot object\n");
//         free(data);
//         return NULL;
//     }

//     // 在 "boot" 对象中查找键
//     char search_key[128];
//     snprintf(search_key, sizeof(search_key), "\"%s\"", key);
//     start = strstr(current_pos, search_key);
//     if (start == NULL || (strchr(current_pos, '}') < start)) {
//         printf("Key not found in boot object\n");
//         free(data);
//         return NULL;
//     }

//     // 查找键值的开始和结束位置
//     start = strchr(start, ':');
//     if (start == NULL) {
//         printf("Invalid JSON format\n");
//         free(data);
//         return NULL;
//     }
//     start++;

//     // 跳过空白字符
//     while (*start == ' ' || *start == '\t' || *start == '\n' || *start == '\r') {
//         start++;
//     }

//     if (*start == '\"') {
//         start++;  // 跳过开始的引号
//         end = strchr(start, '\"');
//         if (end == NULL) {
//             printf("Invalid JSON format: missing closing quote\n");
//             free(data);
//             return NULL;
//         }
//     } else {
//         // 处理非字符串值
//         end = start;
//         while (*end && *end != ',' && *end != '}' && *end != '\n' && *end != '\r') {
//             end++;
//         }
//     }

//     // 计算值的长度并分配内存
//     result_len = end - start;
//     result = (char *)malloc(result_len + 1);
//     if (result == NULL) {
//         printf("Memory allocation failed\n");
//         free(data);
//         return NULL;
//     }

//     // 复制值并添加字符串终止符
//     strncpy(result, start, result_len);
//     result[result_len] = '\0';

//     // 移除尾部的空白字符
//     char *trim_end = result + result_len - 1;
//     while (trim_end > result && (*trim_end == ' ' || *trim_end == '\t' || *trim_end == '\r' || *trim_end == '\n')) {
//         *trim_end = '\0';
//         trim_end--;
//     }

//     free(data);
//     return result;
// }

// char *replace_json_value(const char *json_data, const char *key, const char *new_val)
// {
//     char *new_json_data;
//     const char *boot_start, *key_start, *val_start, *val_end;
//     int len_before, len_after, new_val_len, len_total;
//     char search_key[128];

//     // 首先查找 "boot" 对象
//     boot_start = strstr(json_data, "\"boot\"");
//     if (!boot_start) {
//         printf("Boot object not found\n");
//         return NULL;
//     }

//     // 确保找到的是 "boot" 对象的开始
//     boot_start = strchr(boot_start, '{');
//     if (!boot_start) {
//         printf("Invalid JSON format: no opening brace for boot object\n");
//         return NULL;
//     }

//     // 构造要搜索的键字符串
//     snprintf(search_key, sizeof(search_key), "\"%s\"", key);
    
//     // 在 boot 对象中查找键
//     key_start = strstr(boot_start, search_key);
//     if (!key_start || (strchr(boot_start, '}') < key_start)) {
//         printf("Key not found in boot object\n");
//         return NULL;
//     }

//     // 查找值的开始位置
//     val_start = strchr(key_start, ':');
//     if (!val_start) {
//         printf("Invalid JSON format\n");
//         return NULL;
//     }
//     val_start++;

//     // 跳过空白字符
//     while (*val_start == ' ' || *val_start == '\t' || *val_start == '\n' || *val_start == '\r') {
//         val_start++;
//     }

//     // 确定值的结束位置
//     if (*val_start == '\"') {
//         val_start++;  // 跳过开始的引号
//         val_end = strchr(val_start, '\"');
//         if (val_end) {
//             val_end++;  // 包含结束引号
//         }
//     } else {
//         val_end = strpbrk(val_start, ",}");
//     }

//     if (!val_end) {
//         printf("Invalid JSON format\n");
//         return NULL;
//     }

//     // 计算新字符串的长度
//     len_before = val_start - json_data;
//     len_after = strlen(val_end);
    
//     // 检查新值是否需要添加引号
//     char *formatted_new_val;
//     if ((*val_start == '\"' && new_val[0] != '\"') || 
//         (strchr(new_val, ' ') != NULL)) {
//         // 需要添加引号
//         formatted_new_val = malloc(strlen(new_val) + 3);  // 额外的空间用于引号
//         if (!formatted_new_val) {
//             printf("Memory allocation failed\n");
//             return NULL;
//         }
//         sprintf(formatted_new_val, "\"%s\"", new_val);
//         new_val_len = strlen(formatted_new_val);
//     } else {
//         // 不需要添加引号
//         formatted_new_val = strdup(new_val);
//         if (!formatted_new_val) {
//             printf("Memory allocation failed\n");
//             return NULL;
//         }
//         new_val_len = strlen(formatted_new_val);
//     }

//     // 分配新的 JSON 字符串空间
//     len_total = len_before + new_val_len + len_after;
//     new_json_data = malloc(len_total + 1);
//     if (!new_json_data) {
//         printf("Memory allocation failed\n");
//         free(formatted_new_val);
//         return NULL;
//     }

//     // 构造新的 JSON 字符串
//     strncpy(new_json_data, json_data, len_before - 1);
//     strcpy(new_json_data + len_before - 1, formatted_new_val);
//     strcpy(new_json_data + len_before - 1 + new_val_len, val_end);

//     free(formatted_new_val);
//     return new_json_data;
// }

char *get_value_by_key(const char *json_data, const char *key)
{
    int result_len;
    char *start, *end, *result, *data;
    char *current_pos;
    
    data = strdup(json_data);
    if (data == NULL) {
        printf("Memory allocation failed\n");
        return NULL;
    }

    // 首先查找 "boot" 对象的开始
    current_pos = strstr(data, "\"boot\"");
    if (current_pos == NULL) {
        printf("Boot object not found\n");
        free(data);
        return NULL;
    }

    // 确保找到的是 "boot" 对象
    current_pos = strchr(current_pos, '{');
    if (current_pos == NULL) {
        printf("Invalid JSON format: no opening brace for boot object\n");
        free(data);
        return NULL;
    }

    // 在 "boot" 对象中查找键
    char search_key[128];
    snprintf(search_key, sizeof(search_key), "\"%s\"", key);
    start = strstr(current_pos, search_key);
    if (start == NULL || (strchr(current_pos, '}') < start)) {
        printf("Key not found in boot object\n");
        free(data);
        return NULL;
    }

    // 查找键值的开始和结束位置
    start = strchr(start, ':');
    if (start == NULL) {
        printf("Invalid JSON format\n");
        free(data);
        return NULL;
    }
    start++;

    // 跳过空白字符
    while (*start == ' ' || *start == '\t' || *start == '\n' || *start == '\r') {
        start++;
    }

    // 检查是否有引号并确定结束位置
    if (*start == '\"') {
        start++;  // 跳过开始的引号
        end = strchr(start, '\"');
        if (end == NULL) {
            printf("Invalid JSON format: missing closing quote\n");
            free(data);
            return NULL;
        }
    } else {
        // 如果没有引号，找到下一个逗号或大括号
        end = strpbrk(start, ",}");
        if (end == NULL) {
            printf("Invalid JSON format: missing value terminator\n");
            free(data);
            return NULL;
        }
    }

    // 计算值的长度并分配内存
    result_len = end - start;
    result = (char *)malloc(result_len + 3);  // 额外空间用于可能添加的引号和 null 终止符
    if (result == NULL) {
        printf("Memory allocation failed\n");
        free(data);
        return NULL;
    }

    // 复制值并添加字符串终止符
    if (*start == '\"' || *(start-1) == '\"') {
        // 如果原值已经有引号，直接复制
        strncpy(result, start, result_len);
        result[result_len] = '\0';
    } else {
        // 如果原值没有引号，添加引号
        result[0] = '\"';
        strncpy(result + 1, start, result_len);
        result[result_len + 1] = '\"';
        result[result_len + 2] = '\0';
    }

    // 移除尾部的空白字符
    char *trim_end = result + strlen(result) - 1;
    while (trim_end > result && (*trim_end == ' ' || *trim_end == '\t' || *trim_end == '\r' || *trim_end == '\n')) {
        *trim_end = '\0';
        trim_end--;
    }

    free(data);
    return result;
}

// char *replace_json_value(const char *json_data, const char *key, const char *new_val)
// {
//     char *new_json_data;
//     const char *boot_start, *key_start, *val_start, *val_end;
//     int len_before, len_after, new_val_len, len_total;
//     char search_key[128];

//     // 首先查找 "boot" 对象
//     boot_start = strstr(json_data, "\"boot\"");
//     if (!boot_start) {
//         printf("Boot object not found\n");
//         return NULL;
//     }

//     // 确保找到的是 "boot" 对象的开始
//     boot_start = strchr(boot_start, '{');
//     if (!boot_start) {
//         printf("Invalid JSON format: no opening brace for boot object\n");
//         return NULL;
//     }

//     // 构造要搜索的键字符串
//     snprintf(search_key, sizeof(search_key), "\"%s\"", key);
    
//     // 在 boot 对象中查找键
//     key_start = strstr(boot_start, search_key);
//     if (!key_start || (strchr(boot_start, '}') < key_start)) {
//         printf("Key not found in boot object\n");
//         return NULL;
//     }

//     // 查找值的开始位置
//     val_start = strchr(key_start, ':');
//     if (!val_start) {
//         printf("Invalid JSON format\n");
//         return NULL;
//     }
//     val_start++;

//     // 跳过空白字符
//     while (*val_start == ' ' || *val_start == '\t' || *val_start == '\n' || *val_start == '\r') {
//         val_start++;
//     }

//     // 确定值的结束位置
//     if (*val_start == '\"') {
//         val_start++;  // 跳过开始的引号
//         val_end = strchr(val_start, '\"');
//         if (val_end) {
//             val_end++;  // 包含结束引号
//         }
//     } else {
//         val_end = strpbrk(val_start, ",}");
//     }

//     if (!val_end) {
//         printf("Invalid JSON format\n");
//         return NULL;
//     }

//     // 计算新字符串的长度
//     len_before = val_start - json_data - (*val_start == '\"' ? 1 : 0);  // 如果原值有引号，回退一个位置
//     len_after = strlen(val_end);
    
//     // 准备新值（始终添加引号）
//     char *formatted_new_val;
//     // 如果新值已经包含引号，直接使用
//     if (new_val[0] == '\"' && new_val[strlen(new_val)-1] == '\"') {
//         formatted_new_val = strdup(new_val);
//     } else {
//         // 否则添加引号
//         formatted_new_val = malloc(strlen(new_val) + 3);  // 额外的空间用于引号
//         if (!formatted_new_val) {
//             printf("Memory allocation failed\n");
//             return NULL;
//         }
//         sprintf(formatted_new_val, "\"%s\"", new_val);
//     }
    
//     if (!formatted_new_val) {
//         printf("Memory allocation failed\n");
//         return NULL;
//     }
//     new_val_len = strlen(formatted_new_val);

//     // 分配新的 JSON 字符串空间
//     len_total = len_before + new_val_len + len_after;
//     new_json_data = malloc(len_total + 1);
//     if (!new_json_data) {
//         printf("Memory allocation failed\n");
//         free(formatted_new_val);
//         return NULL;
//     }

//     // 构造新的 JSON 字符串
//     strncpy(new_json_data, json_data, len_before);
//     strcpy(new_json_data + len_before, formatted_new_val);
//     strcpy(new_json_data + len_before + new_val_len, val_end);

//     free(formatted_new_val);
//     return new_json_data;
// }

// char *replace_json_value(const char *json_data, const char *key, const char *new_val)
// {
//     char *new_json_data;
//     const char *boot_start, *key_start, *val_start, *val_end;
//     int len_before, len_after, new_val_len, len_total;
//     char search_key[128];

//     // 首先查找 "boot" 对象
//     boot_start = strstr(json_data, "\"boot\"");
//     if (!boot_start) {
//         printf("Boot object not found\n");
//         return NULL;
//     }

//     // 确保找到的是 "boot" 对象的开始
//     boot_start = strchr(boot_start, '{');
//     if (!boot_start) {
//         printf("Invalid JSON format: no opening brace for boot object\n");
//         return NULL;
//     }

//     // 构造要搜索的键字符串
//     snprintf(search_key, sizeof(search_key), "\"%s\"", key);
    
//     // 在 boot 对象中查找键
//     key_start = strstr(boot_start, search_key);
//     if (!key_start || (strchr(boot_start, '}') < key_start)) {
//         printf("Key not found in boot object\n");
//         return NULL;
//     }

//     // 查找值的开始位置
//     val_start = strchr(key_start, ':');
//     if (!val_start) {
//         printf("Invalid JSON format\n");
//         return NULL;
//     }
//     val_start++;

//     // 跳过空白字符
//     while (*val_start == ' ' || *val_start == '\t' || *val_start == '\n' || *val_start == '\r') {
//         val_start++;
//     }

//     // 确定值的结束位置
//     if (*val_start == '\"') {
//         val_start++;  // 跳过开始的引号
//         val_end = strchr(val_start, '\"');
//         if (val_end) {
//             val_end++;  // 包含结束引号
//         }
//     } else {
//         val_end = strpbrk(val_start, ",}");
//     }

//     if (!val_end) {
//         printf("Invalid JSON format\n");
//         return NULL;
//     }

//     // 计算新字符串的长度
//     len_before = val_start - json_data - (*val_start == '\"' ? 1 : 0);  // 如果原值有引号，回退一个位置
//     len_after = strlen(val_end);
    
//     // 准备新值
//     char *formatted_new_val;
//     size_t new_val_len_raw = strlen(new_val);
    
//     // 检查新值是否已经包含引号
//     if (new_val_len_raw >= 2 && new_val[0] == '\"' && new_val[new_val_len_raw-1] == '\"') {
//         formatted_new_val = strdup(new_val);
//     } else {
//         // 如果不包含引号，则添加引号
//         formatted_new_val = malloc(new_val_len_raw + 3);
//         if (!formatted_new_val) {
//             printf("Memory allocation failed\n");
//             return NULL;
//         }
//         sprintf(formatted_new_val, "\"%s\"", new_val);
//     }
    
//     if (!formatted_new_val) {
//         printf("Memory allocation failed\n");
//         return NULL;
//     }
//     new_val_len = strlen(formatted_new_val);

//     // 分配新的 JSON 字符串空间
//     len_total = len_before + new_val_len + len_after;
//     new_json_data = malloc(len_total + 1);
//     if (!new_json_data) {
//         printf("Memory allocation failed\n");
//         free(formatted_new_val);
//         return NULL;
//     }

//     // 构造新的 JSON 字符串
//     strncpy(new_json_data, json_data, len_before);
//     strcpy(new_json_data + len_before, formatted_new_val);
//     strcpy(new_json_data + len_before + new_val_len, val_end);

//     free(formatted_new_val);
//     return new_json_data;
// }

char *replace_json_value(const char *json_data, const char *key, const char *new_val)
{
    char *new_json_data;
    const char *boot_start, *key_start, *val_start, *val_end;
    int len_before, len_after, new_val_len, len_total;
    char search_key[128];

    // 首先查找 "boot" 对象
    boot_start = strstr(json_data, "\"boot\"");
    if (!boot_start) {
        printf("Boot object not found\n");
        return NULL;
    }

    // 确保找到的是 "boot" 对象的开始
    boot_start = strchr(boot_start, '{');
    if (!boot_start) {
        printf("Invalid JSON format: no opening brace for boot object\n");
        return NULL;
    }

    // 构造要搜索的键字符串
    snprintf(search_key, sizeof(search_key), "\"%s\"", key);
    
    // 在 boot 对象中查找键
    key_start = strstr(boot_start, search_key);
    if (!key_start || (strchr(boot_start, '}') < key_start)) {
        printf("Key not found in boot object\n");
        return NULL;
    }

    // 查找值的开始位置
    val_start = strchr(key_start, ':');
    if (!val_start) {
        printf("Invalid JSON format\n");
        return NULL;
    }
    val_start++;

    // 跳过空白字符
    while (*val_start == ' ' || *val_start == '\t' || *val_start == '\n' || *val_start == '\r') {
        val_start++;
    }

    // 确定值的结束位置
    if (*val_start == '\"') {
        // 跳过开始的引号
        val_start++;
        val_end = strchr(val_start, '\"');
        if (val_end) {
            val_end++;  // 包含结束引号
        }
    } else {
        val_end = strpbrk(val_start, ",}");
    }

    if (!val_end) {
        printf("Invalid JSON format\n");
        return NULL;
    }

    // 计算新字符串的长度
    len_before = key_start - json_data;  // 修改：使用 key_start 而不是 val_start
    len_after = strlen(val_end);
    
    // 准备新的键值对格式
    char *formatted_pair;
    size_t key_len = strlen(key);
    size_t new_val_len_raw = strlen(new_val);
    
    // 分配空间给完整的键值对
    formatted_pair = malloc(key_len + new_val_len_raw + 10);  // 额外空间用于引号、冒号等
    if (!formatted_pair) {
        printf("Memory allocation failed\n");
        return NULL;
    }
    
    // 如果新值已经包含引号，直接使用
    if (new_val_len_raw >= 2 && new_val[0] == '\"' && new_val[new_val_len_raw-1] == '\"') {
        sprintf(formatted_pair, "\"%s\":%s", key, new_val);
    } else {
        // 如果新值不包含引号，添加引号
        sprintf(formatted_pair, "\"%s\":\"%s\"", key, new_val);
    }
    
    new_val_len = strlen(formatted_pair);

    // 分配新的 JSON 字符串空间
    len_total = len_before + new_val_len + len_after;
    new_json_data = malloc(len_total + 1);
    if (!new_json_data) {
        printf("Memory allocation failed\n");
        free(formatted_pair);
        return NULL;
    }

    // 构造新的 JSON 字符串
    strncpy(new_json_data, json_data, len_before);
    strcpy(new_json_data + len_before, formatted_pair);
    strcpy(new_json_data + len_before + new_val_len, val_end);

    free(formatted_pair);
    return new_json_data;
}

char *get_mmc_data(const char *key)
{
    int ret, len;
    int offset = CONFIG_CFG_MMC_BOOT0_OFFSET;
    char *data = NULL, *value_out = NULL;

    ret = mmc_boot_data_get(&data, &len, offset);
    if (ret) {
        printf("Failed to get MMC data: %d\n", ret);
        return NULL;
    }

    if (data == NULL) {
        printf("No data read from MMC\n");
        return NULL;
    }

    printf("%s:%d data:%s\n", __func__, __LINE__, data);

    value_out = get_value_by_key(data, key);

    printf("%s:%d key:%s value_out:%s\n", __func__, __LINE__, key, value_out);

    free(data);
    return value_out;
}

int set_mmc_data(const char *key, const char *new_val)
{
    int ret, len;
    char *new_data = NULL, *data = NULL;
    int offset = CONFIG_CFG_MMC_BOOT0_OFFSET;

    ret = mmc_boot_data_get(&data, &len, offset);
    if (ret) {
        printf("Failed to get MMC data: %d\n", ret);
        return ret;
    }

    if (!data) {
        printf("No data read from MMC\n");
        return -1;
    }

    printf("%s:%d data:%s\n", __func__, __LINE__, data);

    new_data = replace_json_value(data, key, new_val);
    free(data);
    if (!new_data) {
        printf("Failed to replace JSON value\n");
        return -1;
    }

    printf("%s:%d new_data:%s key:%s new_val:%s\n", __func__, __LINE__, new_data, key, new_val);

    ret = mmc_boot_data_save(new_data, strlen(new_data), offset);
    if (ret) {
        printf("Failed to save new MMC data\n");
    }
    free(new_data);

    return ret;
}

// char *get_mmc_data(const char *key)
// {
//     int ret, len;
//     int offset = CONFIG_CFG_MMC_BOOT0_OFFSET;
//     char *data = NULL, *value_out = NULL;
//     cJSON *json = NULL;
//     cJSON *value_item = NULL;

//     // Get data from MMC
//     ret = mmc_boot_data_get(&data, &len, offset);
//     if (ret) {
//         printf("Failed to get MMC  %d\n", ret);
//         return NULL;
//     }

//     if (data == NULL) {
//         printf("No data read from MMC\n");
//         return NULL;
//     }

//     printf("%s:%d %s\n", __func__, __LINE__, data);

//     // Parse JSON string
//     json = cJSON_Parse(data);
//     if (json == NULL) {
//         printf("Error parsing JSON\n");
//         free(data);
//         return NULL;
//     }

//     // Get value by key
//     value_item = cJSON_GetObjectItem(json, key);
//     if (value_item == NULL) {
//         printf("Key not found: %s\n", key);
//         cJSON_Delete(json);
//         free(data);
//         return NULL;
//     }

//     // Get string value
//     if (cJSON_IsString(value_item)) {
//         value_out = strdup(value_item->valuestring); // Make a copy of the string
//     } else {
//         printf("Value is not a string\n");
//         value_out = NULL;
//     }

//     printf("%s:%d key:%s value_out:%s\n", __func__, __LINE__, key, value_out);

//     // Cleanup
//     cJSON_Delete(json);
//     free(data);
//     return value_out;
// }

// int set_mmc_data(const char *key, const char *new_val)
// {
//     int ret, len;
//     char *data = NULL, *new_data = NULL;
//     int offset = CONFIG_CFG_MMC_BOOT0_OFFSET;
//     cJSON *json = NULL;

//     // Get existing data
//     ret = mmc_boot_data_get(&data, &len, offset);
//     if (ret) {
//         printf("Failed to get MMC  %d\n", ret);
//         return ret;
//     }

//     if (!data) {
//         printf("No data read from MMC\n");
//         return -1;
//     }

//     printf("%s:%d %s\n", __func__, __LINE__, data);

//     // Parse JSON
//     json = cJSON_Parse(data);
//     free(data); // Free original data as we don't need it anymore
    
//     if (json == NULL) {
//         printf("Error parsing JSON\n");
//         return -1;
//     }

//     // Replace or add the new value
//     if (cJSON_GetObjectItem(json, key) != NULL) {
//         // Key exists, replace it
//         if (!cJSON_ReplaceItemInObject(json, key, cJSON_CreateString(new_val))) {
//             printf("Failed to replace value\n");
//             cJSON_Delete(json);
//             return -1;
//         }
//     } else {
//         // Key doesn't exist, add it
//         if (!cJSON_AddStringToObject(json, key, new_val)) {
//             printf("Failed to add new value\n");
//             cJSON_Delete(json);
//             return -1;
//         }
//     }

//     // Convert back to string
//     new_data = cJSON_Print(json);
//     cJSON_Delete(json);
    
//     if (!new_data) {
//         printf("Failed to convert JSON to string\n");
//         return -1;
//     }

//     printf("%s:%d new_%s key:%s new_val:%s\n", __func__, __LINE__, new_data, key, new_val);

//     // Save the new data
//     ret = mmc_boot_data_save(new_data, strlen(new_data), offset);
//     if (ret) {
//         printf("Failed to save new MMC data\n");
//     }
//     free(new_data);

//     // Verify the write
//     ret = mmc_boot_data_get(&data, &len, offset);
//     if (ret) {
//         printf("Failed to get MMC  %d\n", ret);
//         return ret;
//     }

//     if (!data) {
//         printf("No data read from MMC\n");
//         return -1;
//     }

//     printf("%s:%d data_r:%s\n", __func__, __LINE__, data);
//     free(data);

//     return ret;
// }
#endif
```

# 分区切换规则

在 U-Boot 根据 boot_part、boota_status、 bootb_status 得出 real_part的值，传递给ramdisk

![[Pasted image 20250122160113.png]]

# DFT
## A 分区
```
cfg add boot.boot_part a
cfg add boot.boota_status success
cfg add boot.bootb_status success
cfg print .
cat /user/system/part
reboot

cfg add boot.boot_part a
cfg add boot.boota_status success
cfg add boot.bootb_status fail
cfg print .
cat /user/system/part
reboot

cfg add boot.boot_part b
cfg add boot.boota_status success
cfg add boot.bootb_status fail
cfg print .
cat /user/system/part
reboot

===================================================================================
# backup分区
ll /run/media/mmcblk0p1

# A分区
ll /run/media/mmcblk0p2
ll /run/media/mmcblk0p3
ll /run/media/mmcblk0p7

# B分区
ll /run/media/mmcblk0p5
ll /run/media/mmcblk0p6
ll /run/media/mmcblk0p8

# overlay分区
ll /run/media/mmcblk0p9
```


## B 分区
```
cfg add boot.boot_part b
cfg add boot.boota_status success
cfg add boot.bootb_status success
cfg print .
cat /user/system/part
reboot

cfg add boot.boot_part b
cfg add boot.boota_status fail
cfg add boot.bootb_status success
cfg print .
cat /user/system/part
reboot

cfg add boot.boot_part a
cfg add boot.boota_status fail
cfg add boot.bootb_status success
cfg print .
cat /user/system/part
reboot


===================================================================================
# backup分区
ll /run/media/mmcblk0p1

# A分区
ll /run/media/mmcblk0p2
ll /run/media/mmcblk0p3
ll /run/media/mmcblk0p7

# B分区
ll /run/media/mmcblk0p5
ll /run/media/mmcblk0p6
ll /run/media/mmcblk0p8

# overlay分区
ll /run/media/mmcblk0p9
```




## 恢复模式
```
cfg add boot.boot_part a
cfg add boot.boota_status fail
cfg add boot.bootb_status fail
cfg print .
cat /user/system/part
reboot


cfg add boot.boot_part b
cfg add boot.boota_status fail
cfg add boot.bootb_status fail
cfg print .
cat /user/system/part
reboot

===================================================================================
# backup分区
ll /run/media/mmcblk0p1

# A分区
ll /run/media/mmcblk0p2
ll /run/media/mmcblk0p3
ll /run/media/mmcblk0p7

# B分区
ll /run/media/mmcblk0p5
ll /run/media/mmcblk0p6
ll /run/media/mmcblk0p8

# overlay分区
ll /run/media/mmcblk0p9
```

# uboot升级

emmc启动，uboot只能从emmc的第一个分区启动，所以uboot如果要升级，只能更新backup.tar

![[Pasted image 20250122141308.png]]

# 查看分区切换
## FIT
![[img_v3_02ip_144bb4fd-fbe7-4040-85e2-76798b737deg.jpg]]
## rootfs

## system
```bash
root@am62xx:~# cat /user/system/part
boot_part:a
```

# ota测试

## 分区表
```txt
################################################################################
##
##                         分区格式说明
##    ----------------------------------------------------------
##
##     每个分区信息由4个字段组成，每个字段间由 “:” 进行分隔
##
##     分区信息格式：
##                 [分区号]:[分区名称]:[分区大小]:[分区格式]
##
##             其中：
##                 [分区号]限定为阿拉伯数字，分区号必须连续
##                 [分区名称]限定为英文字符串（可包含下划线）
##                 [分区大小]单位可选值：KB、MB、GB
##                 [分区格式]可选值：fat32、ext4
##
##     a分区和b分区分别以"_a"和"_b"后缀表示，需保留对应的后缀
##
##     请务必保留下面的六个系统分区，否则系统启动异常
##     backup、boot_a、rootfs_a、boot_b、rootfs_b、overlayfs
##
##     backup 分区格式需固定为fat32
##     backup 分区号固定为 1
##     boot_a、rootfs_a 分区号分别固定为 2 和 3
##     boot_b、rootfs_b 分区号分别固定为 4 和 5
##     overlayfs 必须为最后一个分区，它会自动占据所有剩余未分区空间
##
##     分区5与overlay分区之间的分区为用户自定义分区
##
##    【注意】请谨慎分区，分区升级固件前请备份重要数据，防止数据丢失！！！
################################################################################
1:backup:200MB:fat32
2:boot_a:200MB:fat32
3:rootfs_a:600MB:ext4
4:boot_b:200MB:fat32
5:rootfs_b:600MB:ext4

6:system_a:100MB:ext4
7:system_b:100MB:ext4

8:overlayfs:55MB:ext4
```

## 镜像
1.先拷贝“原始镜像”到TF卡，升级核心板，断电重新上电进入系统
2.然后删除TF卡里面所有的内容，将“ota升级镜像”里面的所有内容拷贝到TF卡
3.将TF卡插入卡槽，执行下面的测试命令

![[Pasted image 20250122160304.png]]

```bash
# ota.sh
#!/bin/bash

set -x

partition="$1"
ota_dir="ota_firmware"

update_ota_firmware() {
    if [ -d "$ota_dir" ]; then
        rm -rf "$ota_dir"
    fi

    mkdir "$ota_dir"

    case "$partition" in
        a)
            cp backup.tar boot_a.tar rootfs_a.tar system_a.tar "$ota_dir/"
            echo "文件已从分区 A 拷贝到 ota_firmware 目录"
            ;;
        b)
            cp backup.tar boot_b.tar rootfs_b.tar system_b.tar "$ota_dir/"
            echo "文件已从分区 B 拷贝到 ota_firmware 目录"
            ;;
        *)
            echo "无效的分区参数！请选择 'a' 或 'b'"
            return 1
            ;;
    esac
}

copy_ota_partition() {
    local tar_file="$1"

    local label=$(echo "$tar_file" | sed 's/\.tar$//')

    local device=$(blkid | grep "LABEL=\"${label}\"" | cut -d: -f1)
    if [ -z "$device" ]; then
        echo "Error: Cannot find device for label ${label}"
        return 1
    fi

    local mount_point=$(df -h | grep "$device" | awk '{print $NF}')
    if [ -z "$mount_point" ]; then
        echo "Error: Cannot find mount point for device ${device}"
        return 1
    fi

    if [ ! -d "$mount_point" ]; then
        echo "Error: Mount point ${mount_point} does not exist"
        return 1
    fi

    local tar_size=$(stat -c%s "${ota_dir}/${tar_file}")
    local available_space=$(df "$mount_point" | tail -n1 | awk '{print $4}')
    available_space=$((available_space * 1024))

    if [ $tar_size -gt $available_space ]; then
        echo "Error: Not enough space in ${mount_point} for ${tar_file}"
        echo "Required: $tar_size bytes"
        echo "Available: $available_space bytes"
        return 1
    fi

    echo "Extracting ${ota_dir}/${tar_file} to ${mount_point}"
    cp -r "${ota_dir}/${tar_file}" ${mount_point}
    if [ $? -ne 0 ]; then
        echo "Error: Failed to extract ${tar_file}"
        return 1
    fi

    sync
    echo "Successfully copied ${tar_file} to ${mount_point}"

    /etc/init.d/ota_upgrade.sh verify_hash "${mount_point}/${tar_file}"

    return 0
}

process_ota_firmware() {
    for tar_file in "${ota_dir}"/*.tar; do
        if [ -f "$tar_file" ]; then
            echo "Processing $(basename $tar_file)..."
            copy_ota_partition "$(basename $tar_file)"
            if [ $? -ne 0 ]; then
                echo "Error processing $(basename $tar_file)"
                return 1
            fi
        fi
    done

    echo "All partitions processed successfully"
    return 0
}

update_ota_firmware "$partition"
process_ota_firmware
```
## 测试命令
### 升级A分区
```bash
cfg print .
dmesg | grep linux
cat /etc/init.d/test_b
cat /user/system/part
cd /run/media/mmcblk1p1
./ota.sh a
```

### 升级B分区
```bash
cfg print .
dmesg | grep linux
cat /etc/init.d/test_b
cat /user/system/part
cd /run/media/mmcblk1p1
./ota.sh b
```